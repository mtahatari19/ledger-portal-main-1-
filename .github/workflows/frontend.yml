name: Frontend CI/CD (Docker on Pi)

on:
  push:
    branches: [main]
    paths:
      - "**/package.json"
      - "**/src/**"
      - ".github/workflows/frontend.yml"
  pull_request:
    branches: [main]
    paths:
      - "**/package.json"
      - "**/src/**"
      - ".github/workflows/frontend.yml"

concurrency:
  group: frontend-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "20"
  IMAGE_NAME: "frontend"
  STABLE_TAG: "current"
  APP_PORT: "18080"
  TEST_OUTPUT: "test-results/junit.xml"

permissions:
  contents: read

jobs:
  detect:
    runs-on: self-hosted
    outputs:
      dir: ${{ steps.loc.outputs.dir }}
    steps:
      - uses: actions/checkout@v4
      - id: preflight
        run: |
          set -euo pipefail
          if sudo -n true 2>/dev/null; then echo "sudo_available=true" >> "$GITHUB_OUTPUT"; else echo "sudo_available=false" >> "$GITHUB_OUTPUT"; fi
      - name: ensure-jq
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            if [ "${{ steps.preflight.outputs.sudo_available }}" = "true" ]; then sudo apt-get update && sudo apt-get install -y jq; else exit 1; fi
          fi
      - id: loc
        env:
          FRONTEND_DIR: ${{ vars.FRONTEND_DIR }}
        run: |
          set -euo pipefail
          if [ -n "${FRONTEND_DIR:-}" ]; then
            [ -d "$FRONTEND_DIR" ] && [ -f "$FRONTEND_DIR/package.json" ] || { echo "invalid FRONTEND_DIR"; exit 2; }
            echo "dir=${FRONTEND_DIR#./}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          mapfile -t PKG_DIRS < <(find . -type f -name package.json -not -path "*/node_modules/*" -printf '%h\n' | sort -u)
          pick_dir() { for d in frontend web app ui client apps/frontend apps/web packages/frontend packages/web; do for p in "${PKG_DIRS[@]}"; do [[ "$p" == "./$d" || "$p" == "$d" ]] && { echo "${p#./}"; return 0; }; done; done; return 1; }
          DIR="$(pick_dir)" || true
          if [ -z "$DIR" ]; then
            for p in "${PKG_DIRS[@]}"; do if jq -e '.scripts.build // empty' "$p/package.json" >/dev/null 2>&1; then DIR="${p#./}"; break; fi; done
          fi
          if [ -z "$DIR" ]; then
            for p in "${PKG_DIRS[@]}"; do if jq -e '(.dependencies//{} + .devDependencies//{}) | has("next") or has("@angular/core") or has("vite") or has("react-scripts") or has("react")' "$p/package.json" >/dev/null; then DIR="${p#./}"; break; fi; done
          fi
          [ -n "$DIR" ] || { echo "frontend not found"; exit 2; }
          echo "dir=$DIR" >> "$GITHUB_OUTPUT"

  test:
    runs-on: self-hosted
    needs: [detect]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - name: install
        working-directory: ${{ needs.detect.outputs.dir }}
        env:
          CI: "true"
        run: |
          npm ci --no-audit --no-fund
      - name: run tests
        working-directory: ${{ needs.detect.outputs.dir }}
        env:
          CI: "true"
        run: |
          mkdir -p "$(dirname "${TEST_OUTPUT}")"
          if npx --yes vitest --version >/dev/null 2>&1; then npx vitest run --reporter=junit --outputFile="${TEST_OUTPUT}" || true; elif npx --yes jest --version >/dev/null 2>&1; then npx jest --ci --reporters=default --reporters=jest-junit && test -f junit.xml && mv junit.xml "${TEST_OUTPUT}" || true; else npm test || true; fi
      - name: New Relic JUnit Reporter
        uses: newrelic/junit-reporter-action@v0.3.0
        with:
          ingestLicenseKey: ${{ secrets.NEW_RELIC_INGEST_LICENSE_KEY }}
          accountId: ${{ secrets.NEW_RELIC_ACCOUNT_ID }}
          region: ${{ vars.NEW_RELIC_REGION }}
          testOutputPath: ${{ needs.detect.outputs.dir }}/${{ env.TEST_OUTPUT }}

  docker_build:
    runs-on: self-hosted
    needs: [detect, test]
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - id: meta
        run: |
          set -euo pipefail
          echo "image_ref=${{ env.IMAGE_NAME }}:${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
      - uses: docker/build-push-action@v6
        with:
          context: ${{ needs.detect.outputs.dir }}
          file: ${{ needs.detect.outputs.dir }}/Dockerfile
          tags: ${{ env.IMAGE_NAME }}:${{ github.sha }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_VERSION=${{ env.NODE_VERSION }}

  deploy:
    runs-on: self-hosted
    needs: [docker_build]
    if: github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4
      - run: |
          set -euo pipefail
          docker tag "${{ env.IMAGE_NAME }}:${GITHUB_SHA}" "${{ env.IMAGE_NAME }}:${{ env.STABLE_TAG }}"
          cd deploy
          docker compose up -d --no-deps frontend
          for i in $(seq 1 15); do
            sleep 2
            if curl -fsS -I "http://localhost:${{ env.APP_PORT }}/" >/dev/null 2>&1; then exit 0; fi
          done
          docker compose logs --no-color --tail=200 frontend || true
          exit 1
