name: Frontend CI/CD (Self-Hosted on Pi)

on:
  push:
    branches: [main]
    paths:
      - "**/package.json"
      - "**/src/**"
      - ".github/workflows/frontend.yml"
  pull_request:
    branches: [main]
    paths:
      - "**/package.json"
      - "**/src/**"
      - ".github/workflows/frontend.yml"

concurrency:
  group: frontend-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "20"
  TEST_OUTPUT: "test-results/junit.xml"

permissions:
  contents: read

jobs:
  detect:
    runs-on: self-hosted
    outputs:
      dir: ${{ steps.loc.outputs.dir }}
      sudo_available: ${{ steps.preflight.outputs.sudo_available }}
    steps:
      - uses: actions/checkout@v4
      - id: preflight
        run: |
          set -euo pipefail
          if sudo -n true 2>/dev/null; then
            echo "sudo_available=true" >> "$GITHUB_OUTPUT"
          else
            echo "sudo_available=false" >> "$GITHUB_OUTPUT"
          fi
      - name: ensure-jq
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            if [ "${{ steps.preflight.outputs.sudo_available }}" = "true" ]; then
              sudo apt-get update && sudo apt-get install -y jq
            else
              exit 1
            fi
          fi
      - id: loc
        env:
          FRONTEND_DIR: ${{ vars.FRONTEND_DIR }}
        run: |
          set -euo pipefail
          if [ -n "${FRONTEND_DIR:-}" ]; then
            [ -d "$FRONTEND_DIR" ] && [ -f "$FRONTEND_DIR/package.json" ] || { echo "FRONTEND_DIR invalid"; exit 2; }
            echo "dir=${FRONTEND_DIR#./}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          mapfile -t PKG_DIRS < <(find . -type f -name package.json -not -path "*/node_modules/*" -printf '%h\n' | sort -u)
          pick_dir() {
            for d in frontend web app ui client apps/frontend apps/web packages/frontend packages/web; do
              for p in "${PKG_DIRS[@]}"; do
                if [[ "$p" == "./$d" || "$p" == "$d" ]]; then echo "${p#./}"; return 0; fi
              done
            done
            return 1
          }
          DIR="$(pick_dir)" || true
          if [ -z "$DIR" ]; then
            for p in "${PKG_DIRS[@]}"; do
              if jq -e '.scripts.build // empty' "$p/package.json" >/dev/null 2>&1; then DIR="${p#./}"; break; fi
            done
          fi
          if [ -z "$DIR" ]; then
            for p in "${PKG_DIRS[@]}"; do
              if jq -e '(.dependencies//{} + .devDependencies//{}) | has("next") or has("@angular/core") or has("vite") or has("react-scripts") or has("react")' "$p/package.json" >/dev/null; then DIR="${p#./}"; break; fi
            done
          fi
          [ -n "$DIR" ] || { echo "frontend not found"; exit 2; }
          echo "dir=$DIR" >> "$GITHUB_OUTPUT"

  build_test:
    runs-on: self-hosted
    needs: [detect]
    outputs:
      outdir: ${{ steps.build.outputs.dir }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - name: prepare-cache
        run: |
          set -euo pipefail
          mkdir -p "${GITHUB_WORKSPACE}/.npm-cache/_cacache"
          echo "NPM_CONFIG_CACHE=${GITHUB_WORKSPACE}/.npm-cache" >> "$GITHUB_ENV"
      - name: cache-npm-store
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/.npm-cache
          key: npmstore-${{ runner.os }}-${{ env.NODE_VERSION }}-${{ hashFiles(format('{0}/package-lock.json', needs.detect.outputs.dir)) }}
          restore-keys: |
            npmstore-${{ runner.os }}-${{ env.NODE_VERSION }}-
      - name: cache-node-modules
        uses: actions/cache@v4
        with:
          path: ${{ needs.detect.outputs.dir }}/node_modules
          key: nm-${{ runner.os }}-${{ env.NODE_VERSION }}-${{ hashFiles(format('{0}/package-lock.json', needs.detect.outputs.dir)) }}
          restore-keys: |
            nm-${{ runner.os }}-${{ env.NODE_VERSION }}-
      - name: cache-build-tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/nx
            ~/.vite
            ${{ needs.detect.outputs.dir }}/.next/cache
            ${{ needs.detect.outputs.dir }}/.angular/cache
          key: bt-${{ runner.os }}-${{ env.NODE_VERSION }}-${{ github.sha }}
          restore-keys: |
            bt-${{ runner.os }}-${{ env.NODE_VERSION }}-
      - name: assert-lockfile
        run: |
          set -euo pipefail
          test -f "${{ needs.detect.outputs.dir }}/package-lock.json" || { echo "no lockfile"; exit 2; }
      - name: install
        working-directory: ${{ needs.detect.outputs.dir }}
        env:
          HUSKY: "0"
          CI: "true"
          NPM_CONFIG_CACHE: ${{ env.NPM_CONFIG_CACHE }}
          NPM_CONFIG_PROGRESS: "false"
          NPM_CONFIG_AUDIT: "false"
          NPM_CONFIG_FUND: "false"
          NPM_CONFIG_MAXSOCKETS: "50"
          NPM_CONFIG_FETCH_RETRIES: "5"
          NPM_CONFIG_FETCH_RETRY_MINTIMEOUT: "1000"
          NPM_CONFIG_FETCH_RETRY_MAXTIMEOUT: "60000"
        run: npm ci --prefer-offline --no-audit --no-fund --cache "$NPM_CONFIG_CACHE"
      - id: build
        name: build
        working-directory: ${{ needs.detect.outputs.dir }}
        env:
          HUSKY: "0"
          CI: "true"
        run: |
          set -euo pipefail
          if jq -e '.scripts.build // empty' package.json >/dev/null 2>&1; then
            npm run build
          else
            if jq -e '(.dependencies//{} + .devDependencies//{}) | has("@angular/core")' package.json >/dev/null; then
              npx ng build --configuration production || npx nx build || npm run build
            elif jq -e '(.dependencies//{} + .devDependencies//{}) | has("next")' package.json >/dev/null; then
              npx next build
              if jq -e '.scripts | has("export")' package.json >/dev/null 2>&1; then npm run export; fi
            elif jq -e '(.dependencies//{} + .devDependencies//{}) | has("vite")' package.json >/dev/null; then
              npx vite build
            elif jq -e '(.dependencies//{} + .devDependencies//{}) | has("react-scripts")' package.json >/dev/null; then
              npx react-scripts build
            else
              echo "No build script and no known framework detected"; exit 1
            fi
          fi
          OUT="build"
          if [ -f angular.json ]; then
            DEFAULT_PROJECT=$(jq -r '.defaultProject // empty' angular.json)
            [ -z "$DEFAULT_PROJECT" -o "$DEFAULT_PROJECT" = "null" ] && DEFAULT_PROJECT=$(jq -r '.projects | keys[0]' angular.json)
            OUT=$(jq -r --arg p "$DEFAULT_PROJECT" '.projects[$p].architect.build.options.outputPath // .projects[$p].targets.build.options.outputPath // "dist"' angular.json)
          elif [ -d dist ]; then OUT="dist"
          elif [ -d build ]; then OUT="build"
          elif [ -d out ]; then OUT="out"
          elif [ -d .next ]; then OUT=".next"
          fi
          echo "dir=$OUT" >> "$GITHUB_OUTPUT"
      - name: test
        working-directory: ${{ needs.detect.outputs.dir }}
        env:
          CI: "true"
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${TEST_OUTPUT}")"
          if npx --yes vitest --version >/dev/null 2>&1; then
            npx vitest run --reporter=junit --outputFile="${TEST_OUTPUT}" || true
          elif npx --yes jest --version >/dev/null 2>&1; then
            npx jest --ci --reporters=default --reporters=jest-junit || true
            if [ -f junit.xml ]; then mkdir -p "$(dirname "${TEST_OUTPUT}")"; mv junit.xml "${TEST_OUTPUT}"; fi
          else
            npm test || true
          fi
      - name: newrelic-junit
        uses: newrelic/junit-reporter-action@v0.3.0
        with:
          ingestLicenseKey: ${{ secrets.NEW_RELIC_INGEST_LICENSE_KEY }}
          accountId: ${{ secrets.NEW_RELIC_ACCOUNT_ID }}
          region: ${{ vars.NEW_RELIC_REGION }}
          testOutputPath: ${{ needs.detect.outputs.dir }}/${{ env.TEST_OUTPUT }}

  deploy:
    runs-on: self-hosted
    needs: [build_test]
    steps:
      - uses: actions/checkout@v4
      - name: deploy-local
        env:
          OUT_DIR: ${{ needs.build_test.outputs.outdir }}
          ROOT_DIR: ${{ vars.FRONTEND_ROOT }}
          SUDO_AVAILABLE: ${{ needs.detect.outputs.sudo_available }}
        run: |
          set -euo pipefail
          SUDO=""
          if [ "$SUDO_AVAILABLE" = "true" ]; then SUDO="sudo"; fi
          ROOT="${ROOT_DIR:-/srv/www/frontend}"
          RELEASES="$ROOT/releases"
          CURRENT="$ROOT/current"
          NEW="$RELEASES/${GITHUB_SHA}"
          $SUDO mkdir -p "$RELEASES" "$NEW"
          set +e
          $SUDO rsync -a --delete "${{ needs.detect.outputs.dir }}/$OUT_DIR"/ "$NEW"/
          RC=$?
          set -e
          if [ "$RC" -ne 0 ] && [ "$RC" -ne 24 ]; then exit "$RC"; fi
          if [ ! -f "$NEW/index.html" ] && [ "$(find "$NEW" -mindepth 1 -maxdepth 1 -type d | wc -l)" -eq 1 ]; then
            INNER=$(find "$NEW" -mindepth 1 -maxdepth 1 -type d | head -n1)
            TMP=$(mktemp -d)
            $SUDO rsync -a "$INNER"/ "$TMP"/
            $SUDO rm -rf "$NEW"/*
            $SUDO rsync -a "$TMP"/ "$NEW"/
            $SUDO rm -rf "$TMP" "$INNER" || true
          fi
          $SUDO ln -sfn "$NEW" "$CURRENT"
          $SUDO bash -c 'ls -1dt '"$RELEASES"'/* | tail -n +6 | xargs -r rm -rf'
          if [ -n "$SUDO" ]; then
            $SUDO chown -R deploy:www-data "$ROOT"
            $SUDO find "$ROOT" -type d -exec chmod 755 {} \;
            $SUDO find "$ROOT" -type f -exec chmod 644 {} \;
            $SUDO nginx -t && $SUDO systemctl reload nginx || true
          fi
